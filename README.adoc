---
tags: [spring-cloud, ribbon]
projects: [spring-cloud, spring-cloud-netflix]
---
:spring_version: current
:spring_boot_version: 1.5.2.RELEASE
:toc:
:icons: font
:source-highlighter: prettify
:project_id: gs-client-side-load-balancing
本指南会带你走一遍使用 Netflix Ribbon 为微服务应用提供客户端负载均衡的过程。

== 你将做出什么

你会构建一个在调用另一个微服务应用的时候使用Netflix Ribbon和Spring Cloud Netflix提供客户端负载均衡的微服务应用。

== 你需要什么

:java_version: 1.8
include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/prereq_editor_jdk_buildtools.adoc[]

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/how_to_complete_this_guide.adoc[]

[[reveal-gradle]]
[.reveal-gradle]
== 使用Gradle构建

[[scratch]]
[.use-gradle]
== 使用Gradle构建

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/build_system_intro.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/create_directory_structure_hello.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/create_both_builds.adoc[]

`say-hello/build.gradle`
// AsciiDoc source formatting doesn't support groovy, so using java instead
[source,java]
----
include::initial/say-hello/build.gradle[]
----

`user/build.gradle`
// AsciiDoc source formatting doesn't support groovy, so using java instead
[source,java]
----
include::initial/user/build.gradle[]
----

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/spring-boot-gradle-plugin.adoc[]

[[reveal-maven]]
[.reveal-maven]
== 使用Maven构建

[[use-maven]]
[.use-maven]
== 使用Maven构建

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/build_system_intro_maven.adoc[]

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/create_directory_structure_hello.adoc[]

`say-hello/pom.xml`
[source,xml]
----
include::initial/say-hello/pom.xml[]
----

`user/pom.xml`
[source,xml]
----
include::initial/user/pom.xml[]
----

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/spring-boot-maven-plugin.adoc[]

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/hide-show-sts.adoc[]



[[initial]]
== 编写服务器服务

我们的 &#8220;服务器&#8221; 服务就是说你好。它将返回一个随机问候语（从三个静态列表中挑选出来），从可访问的端点 `/greeting` 返回。

在 `src/main/java/hello`, 创建一个文件 `SayHelloApplication.java`. 它应该看起来像这样:

`say-hello/src/main/java/hello/SayHelloApplication.java`
[source,java]
----
include::complete/say-hello/src/main/java/hello/SayHelloApplication.java[]
----

`@RestController` 注解和一起使用`@Controller` 与 `@ResponseBody` 的效果是一样的. 它标志着 `SayHelloApplication` 作为一个控制器类（就像 `@Controller` 做的一样）并确保返回值类的 `@RequestMapping` 方法将自动转换为适当的类型，从原来直接写入响应体（就像 `@Controller` 做的一样）。我们有一个 `@RequestMapping` 方法生成 `/greeting` 然后另一个方法生成根路径 `/` 。（当我们稍后开始使用Ribbon的时候，我们会想要第二种方法。）

我们要在本地运行该应用程序的多个实例的本地与客户服务应用，所以我们来创建目录 `src/main/resources` ，在里面创建文件 `application.yml` ，然后在那个文件，为 `server.port` 设置一个默认值 。（我们还将指示应用程序的其他实例在其他端口上运行，这样当我们运行时，没有一个说hello实例会与客户端发生冲突）。当我们在修改这个文件中的时候，我们也可以为我们的服务设置 `spring.application.name` 。

`say-hello/src/main/resources/application.yml`
[source,yaml]
----
include::complete/say-hello/src/main/resources/application.yml[]
----

== 从客户端服务访问

我们用户将看到这个用户应用。它会访问说“hello”的应用程序以获得问候，然后当用户访问 `/hi` 端点时，将其发送给我们的用户。

在用户应用程序目录，在 `src/main/java/hello`，添加文件 `UserApplication.java` ：

`user/src/main/java/hello/UserApplication.java`
[source,java]
----
package hello;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
@RestController
public class UserApplication {

  @Bean
  RestTemplate restTemplate(){
    return new RestTemplate();
  }

  @Autowired
  RestTemplate restTemplate;

  @RequestMapping("/hi")
  public String hi(@RequestParam(value="name", defaultValue="Artaban") String name) {
    String greeting = this.restTemplate.getForObject("http://localhost:8090/greeting", String.class);
    return String.format("%s, %s!", greeting, name);
  }

  public static void main(String[] args) {
    SpringApplication.run(UserApplication.class, args);
  }
}
----

为了从说 "Hello" 的应用中获得问候，我们用的是Spring的 `RestTemplate` 模板类。 `RestTemplate` 使HTTP GET来请求我们提供的说 "Hello" 服务的URL，并返回一个 `String` 作为结果。（欲了解更多关于使用Spring使用REST式服务的信息，请参见下面的 https://spring.io/guides/gs/consuming-rest/[Consuming a RESTful Web Service] 指南）。

添加 `spring.application.name` 和 `server.port` 属性到 `src/main/resources/application.properties` 或者 `src/main/resources/application.yml`:

`user/src/main/resources/application.yml`
[source,yaml]
----
spring:
  application:
    name: user

server:
  port: 8888
----

== 跨服务器实例的负载平衡

现在我们可以在用户服务上访问 `/hi` ，看到一个友好的问候语：

----
$ curl http://localhost:8888/hi
Greetings, Artaban!

$ curl http://localhost:8888/hi?name=Orontes
Salutations, Orontes!
----

为了跨越一个硬编码的服务器URL到一个负载均衡的解决方案，让我们设置Ribbon。在 `application.yml` 文件下 `user/src/main/resources/` ，添加以下属性:

`user/src/main/resources/application.yml`
[source,yaml]
----
say-hello:
  ribbon:
    eureka:
      enabled: false
    listOfServers: localhost:8090,localhost:9092,localhost:9999
    ServerListRefreshInterval: 15000
----

这种配置属性在Ribbon _client_。Spring Cloud Netflix创造在我们的应用程序中每个带客户名称` ApplicationContext `。这用于给客户端提供一组用于带状组件实例的bean，包括：This configures properties on a Ribbon _client_. Spring Cloud Netflix creates an `ApplicationContext` for each Ribbon client name in our application. This is used to give the client a set of beans for instances of Ribbon components, including:

* an `IClientConfig`, which stores client configuration for a client or load balancer,
* an `ILoadBalancer`, which represents a software load balancer,
* a `ServerList`, which defines how to get a list of servers to choose from,
* an `IRule`, which describes a load balancing strategy, and
* an `IPing`, which says how periodic pings of a server are performed.

In our case above, the client is named `say-hello`. The properties we set are `eureka.enabled` (which we set to `false`), `listOfServers`, and `ServerListRefreshInterval`. Load balancers in Ribbon normally get their server lists from a Netflix Eureka service registry. (See the https://spring.io/guides/gs/service-registration-and-discovery/[Service Registration and Discovery] guide for information on using a Eureka service registry with Spring Cloud.) For our simple purposes here, we're skipping Eureka, so we set the `ribbon.eureka.enabled` property to `false` and instead give Ribbon a static `listOfServers`. `ServerListRefreshInterval` is the interval, in milliseconds, between refreshes of Ribbon's service list.

In our `UserApplication` class, switch the `RestTemplate` to use the Ribbon client to get the server address for Say Hello:

`user/src/main/java/hello/UserApplication.java`
[source,java]
----
include::complete/user/src/main/java/hello/UserApplication.java[]
----

We've made a couple of other related changes to the `UserApplication` class. Our `RestTemplate` is now also marked as `LoadBalanced`; this tells Spring Cloud that we want to take advantage of its load balancing support (provided, in this case, by Ribbon). The class is annotated with `@RibbonClient`, which we give the `name` of our client (`say-hello`) and then another class, which contains extra `configuration` for that client.

We'll need to create that class. Add a new file, `SayHelloConfiguration.java`, in the `user/src/main/java/hello` directory:

`user/src/main/java/hello/SayHelloConfiguration.java`
[source,java]
----
include::complete/user/src/main/java/hello/SayHelloConfiguration.java[]
----

We can override any Ribbon-related bean that Spring Cloud Netflix gives us by creating our own bean with the same name. Here, we override the `IPing` and `IRule` used by the default load balancer. The default `IPing` is a `NoOpPing` (which doesn't actually ping server instances, instead always reporting that they're stable), and the default `IRule` is a `ZoneAvoidanceRule` (which avoids the Amazon EC2 zone that has the most malfunctioning servers, and might thus be a bit difficult to try out in our local environment).

Our `IPing` is a `PingUrl`, which will ping a URL to check the status of each server. Say Hello has, as you'll recall, a method mapped to the `/` path; that means that Ribbon will get an HTTP 200 response when it pings a running Say Hello server. The `IRule` we set up, the `AvailabilityFilteringRule`, will use Ribbon's built-in circuit breaker functionality to filter out any servers in an &#8220;open-circuit&#8221; state: if a ping fails to connect to a given server, or if it gets a read failure for the server, Ribbon will consider that server &#8220;dead&#8221; until it begins to respond normally.

[NOTE]
====
The `@SpringBootApplication` annotation on the `UserApplication` class is equivalent to (among others) the `@Configuration` annotation that marks a class as a source of bean definitions. This is why we don't need to annotate the `SayHelloConfiguration` class with `@Configuration`: since it's in the same package as `UserApplication`, it is already being scanned for bean methods.

This approach does mean that our Ribbon configuration will be part of the main application context and therefore shared by _all_ Ribbon clients in the User application. In a normal application, you can avoid this by keeping Ribbon beans out of the main application context (e.g., in this example, you could put `SayHelloConfiguration` in a different package from `UserApplication`).
====

== 试一下

Run the Say Hello service, using either Gradle:

----
$ ./gradlew bootRun
----

or Maven:

----
$ mvn spring-boot:run
----

Run other instances on ports 9092 and 9999, again using either Gradle:

----
$ SERVER_PORT=9092 ./gradlew bootRun
----

or Maven:

----
$ SERVER_PORT=9999 mvn spring-boot:run
----

Then start up the User service. Access `localhost:8888/hi` and then watch the Say Hello service instances. You can see Ribbon's pings arriving every 15 seconds:

----
2016-03-09 21:13:22.115  INFO 90046 --- [nio-8090-exec-1] hello.SayHelloApplication                : Access /
2016-03-09 21:13:22.629  INFO 90046 --- [nio-8090-exec-3] hello.SayHelloApplication                : Access /
----

And your requests to the User service should result in calls to Say Hello being spread across the running instances in round-robin form:

----
2016-03-09 21:15:28.915  INFO 90046 --- [nio-8090-exec-7] hello.SayHelloApplication                : Access /greeting
----

Now shut down a Say Hello server instance. Once Ribbon has pinged the down instance and considers it down, you should see requests begin to be balanced across the remaining instances.

== Summary

祝贺你!您刚刚开发了一个Spring应用程序，它为调用另一个应用程序执行客户端负载平衡。



include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/footer.adoc[]

